#include "hypdefs.h"
#include "hypdebug.h"
#include "hcp_opts.h"
#include "pdf.h"

/*
 * gzip header:
 *    magic 0x1f 0x8b
 *    cm    0x08
 *    flg   0x00
 *    mtime 0x00 0x00 0x00 0x00
 *    xfl   0x02
 *    os    0x03
 * 
 *
 * deflate stream header:
 *   CMF FLG
 *
 *   CMF: compression method and flags
 *        0..3: CM compression method (8)
 *        4..7: CINFO compression info (ln2 window-size, minus 8)
 *              eg. value of 7 = 1 << 15 = 32k windows size
 *
 *   FLG: Flags
 *        0..4 FCHECK check bits for CMF and FLG
 *             (CMF*256 + FLG) must be multiple of 31
 *        5    FDICT preset dictionary
 *             if set, a DICTID identifier follows
 *        6..7 Compression level (informative only)
 */

/*
 * node/label names are case sensitiv
 */
#define namecmp strcmp

/* ------------------------------------------------------------------------- */

static void pdf_error_handler(HPDF_STATUS error_no, HPDF_STATUS detail_no, void *user_data)
{
	PDF *pdf = (PDF *)user_data;
	hyp_utf8_fprintf(pdf->opts->errorfile, "PDF ERROR: error_no=%04X, detail_no=%u\n", (unsigned int) error_no, (unsigned int) detail_no);
	longjmp(pdf->error_env, 1);
}


/* ------------------------------------------------------------------------- */

PDF *pdf_new(hcp_opts *opts)
{
	PDF *pdf;
	
	pdf = g_new(PDF, 1);
	if (pdf == NULL)
		return pdf;
	pdf->opts = opts;
	pdf->hpdf = HPDF_New(pdf_error_handler, pdf);
	HPDF_SetCompressionMode(pdf->hpdf, HPDF_COMP_ALL);
	pdf->font = HPDF_GetFont(pdf->hpdf, "Helvetica", NULL);
	return pdf;
}
	
/* ------------------------------------------------------------------------- */

void pdf_delete(PDF *pdf)
{
	if (pdf == NULL)
		return;
	HPDF_Free(pdf->hpdf);
	g_free(pdf);
}

/* ------------------------------------------------------------------------- */

static gboolean pdf_out_node(HYP_DOCUMENT *hyp, hcp_opts *opts, PDF *pdf, hyp_nodenr node)
{
	(void) hyp;
	(void) opts;
	(void) pdf;
	(void) node;
	return TRUE;
}

/* ------------------------------------------------------------------------- */

static char *pdf_datestr(time_t t)
{
	struct tm tm;
	int gmtoff;
	int c;
	
	localtime_r(&t, &tm);
	gmtoff = (int)(tm.tm_gmtoff / 60);
	c = gmtoff < 0 ? '-' : '+';
	if (gmtoff < 0)
		gmtoff = -gmtoff;
	return g_strdup_printf("D:%04d%02d%02d%02d%02d%02d%c%02d'%02d'",
		tm.tm_year + 1900,
		tm.tm_mon + 1,
		tm.tm_mday,
		tm.tm_hour,
		tm.tm_min,
		tm.tm_sec,
		c,
		gmtoff / 60,
		gmtoff % 60);
}

/* ------------------------------------------------------------------------- */

void pdf_out_globals(HYP_DOCUMENT *hyp, PDF *pdf)
{
	char *str;
	struct stat s;
	
#define STR(t, x) \
	if (x != NULL) \
	{ \
		HPDF_SetInfoAttr(pdf->hpdf, t, x); \
	}

	STR(HPDF_INFO_TITLE, hyp->database);
	STR(HPDF_INFO_AUTHOR, hyp->author);
	STR(HPDF_INFO_SUBJECT, hyp->subject);

	HPDF_SetInfoAttr(pdf->hpdf, HPDF_INFO_CREATOR, hyp->comp_vers >= 6 || hyp->language != NULL ? gl_program_name : "ST-GUIDE");
	str = g_strdup_printf("%s %s for %s, using Haru Free PDF Library %s", gl_program_name, gl_program_version, hyp_osname(hyp_get_current_os()), HPDF_GetVersion());
	STR(HPDF_INFO_PRODUCER, str);
	g_free(str);
	if (hyp_utf8_stat(hyp->file, &s) == 0)
	{
		str = pdf_datestr(s.st_mtime);
		STR(HPDF_INFO_CREATION_DATE, str);
		g_free(str);
	}

#undef STR
}

/* ------------------------------------------------------------------------- */

gboolean recompile_pdf(HYP_DOCUMENT *hyp, hcp_opts *opts, int argc, const char **argv)
{
	hyp_nodenr node;
	INDEX_ENTRY *entry;
	volatile gboolean ret;
	int i;
	gboolean found;
	PDF *pdf;
	HPDF_Stream stream;
	HPDF_UINT idx, length;
	HPDF_BYTE *buf;
	
	/* force_crlf = FALSE; */

	ret = TRUE;
		
	if (opts->read_images && hyp->cache == NULL)
		InitCache(hyp);
	
	pdf = pdf_new(opts);

	if (setjmp(pdf->error_env))
	{
		pdf_delete(pdf);
		return FALSE;
	}
		
	/* g_string_append_printf(pdf->out, "%% This file was automatically generated by %s version %s\n", gl_program_name, gl_program_version); */
	pdf_out_globals(hyp, pdf);

	for (node = 0; node < hyp->num_index; node++)
	{
		entry = hyp->indextable[node];
		if (argc == 0)
		{
			found = TRUE;
		} else
		{
			found = FALSE;
			for (i = 0; i < argc; i++)
			{
				if (argv[i])
				{
					char *s1, *s2;
					
					s1 = hyp_conv_to_utf8(hyp->comp_charset, entry->name, STR0TERM);
					s2 = hyp_conv_to_utf8(hyp_get_current_charset(), argv[i], STR0TERM);
					if (namecmp(s1, s2) == 0)
					{
						argv[i] = NULL;
						found = TRUE;
					}
					g_free(s2);
					g_free(s1);
				}
			}
		}
		if (!found)
			continue;

		if (node == hyp->index_page)
		{
			if (!opts->gen_index || argc != 0)
				continue;
		}

		switch ((hyp_indextype) entry->type)
		{
		case HYP_NODE_INTERNAL:
		case HYP_NODE_POPUP:
			ret &= pdf_out_node(hyp, opts, pdf, node);
			break;
		case HYP_NODE_IMAGE:
		case HYP_NODE_EXTERNAL_REF:
		case HYP_NODE_SYSTEM_ARGUMENT:
		case HYP_NODE_REXX_SCRIPT:
		case HYP_NODE_REXX_COMMAND:
		case HYP_NODE_QUIT:
		case HYP_NODE_CLOSE:
		case HYP_NODE_EOF:
		default:
			break;
		}
	}

	{
		HPDF_Page page;
		
		page = HPDF_AddPage(pdf->hpdf);
		HPDF_Page_SetRGBFill(page, 1.0, 0, 0);
		HPDF_Page_SetFontAndSize(page, pdf->font, 24); 
		HPDF_Page_SetTextRenderingMode(page, HPDF_FILL);
		HPDF_Page_BeginText(page);
		HPDF_Page_TextOut(page, 100, 500, "Hello, world");
		HPDF_Page_EndText(page);
	}
	
	HPDF_SaveToStream(pdf->hpdf, &stream);
	idx = 0;
	while ((buf = HPDF_MemStream_GetBufPtr(stream, idx, &length)) != NULL)
	{
		fwrite(buf, 1, length, opts->outfile);
		idx++;
	}

	for (i = 0; i < argc; i++)
	{
		if (argv[i] != NULL)
		{
			hyp_utf8_fprintf(opts->errorfile, _("'%s' not found.\n"), argv[i]);
			ret = FALSE;
		}
	}
	
	pdf_delete(pdf);

	return ret;
}
